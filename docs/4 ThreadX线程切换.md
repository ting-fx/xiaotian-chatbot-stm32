# ThreadX 线程切换机制

![alt text](<imgs/4 ThreadX线程切换-1.png>)

## PendSV

PendSV 是 Cortex-M 内核提供的一种 可挂起（Pendable）、优先级最低的异常，专门用于在合适且安全的时机执行操作系统相关的工作，最典型的用途就是 线程上下文切换（Context Switch）。

## PendSV触发时机

当ThreadX判断需要切换线程时，会通过软件方式触发PendSV，随后，在合适的时机，PendSV_Handler 被执行，完成线程上下文切换。

在实际运行过程中，PendSV 的触发场景非常多，比如：

#### 1. 线程等不到资源进入阻塞状态（Running → Suspend）

例如，某个线程在获取信号量时：
```c
tx_semaphore_get(&sem, TX_WAIT_FOREVER);
```

如果当前信号量不可用：

- 当前线程会从 Running 状态进入 Suspended
- 调度器需要重新选择一个就绪队列中优先级最高的线程
- 触发PendSV，请求进行线程切换
- PendSV 执行后，CPU 切换到新的线程运行

#### 2. 更高优先级线程被唤醒（Ready → Running）

例如，某个线程或中断中执行：
```c
tx_semaphore_put(&sem);
```

此时如果：

- 有一个更高优先级线程正在等待该信号量
- 该线程从 Suspended 状态变为 Ready
- 且其优先级高于当前正在运行的线程

## Cortex-M 中断机制基础

Cortex-M 处理器针对嵌入式实时系统的特点，提供了高效、硬件自动化的中断响应机制，使得中断函数能够直接使用 C 语言编写，而无需传统的汇编“中断入口/出口”代码。


### 1. 寄存器概览

| 寄存器 | 名称 | 说明 |
|--------|------|------|
| R0–R12 | 通用寄存器 | 用于存放数据和中间结果 |
| R13 (SP) | 栈指针 | 指向当前栈顶。Cortex-M 有两种栈指针：<br>• **MSP**（Main Stack Pointer）：复位后默认使用，用于中断和特权级任务<br>• **PSP**（Process Stack Pointer）：用于线程模式的普通任务 |
| R14 (LR) | 链接寄存器 | 存储函数调用的返回地址。当主函数调用子函数时，下一条指令地址会保存到 LR |
| R15 (PC) | 程序计数器 | 指向即将执行的指令地址 |


### 2. C 语言函数调用机制（普通函数）

Cortex-M 遵循 **AAPCS（ARM Procedure Call Standard）** 调用约定：

- **R0–R3**：用于传递函数参数和返回值，调用子函数时，这些寄存器的值可以被覆盖。  
- **R4–R11**：被调用者若使用这些寄存器，必须先入栈，返回前再恢复。  
- **LR（R14）**：保存返回地址。


### 3. 中断调用机制

在某些传统 MCU（如 ARM7）中，中断发生时，CPU不会自动保存 R0–R3，因此中断函数通常需要用汇编手动压栈和出栈，保证现场保护。

而 **Cortex-M 通过硬件自动压栈机制**，大大简化了中断编写流程。

当中断发生时，硬件会自动将以下寄存器压入当前使用的栈（MSP 或 PSP）中：

- R0–R3  
- R12  
- LR（调用时的链接寄存器）  
- PC（中断触发时的下一条指令地址）  
- xPSR（程序状态寄存器）

这一过程称为 **自动堆栈（Exception Entry Stacking）**。

### 4. 中断返回机制

为了区分“普通函数调用返回”和“中断返回”，Cortex-M 在中断进入时会修改 LR 的值为一个特殊标志（例如 `0xFFFFFFF9` 或 `0xFFFFFFFD`），用于指示返回路径。

当中断服务函数执行 `BX LR` 时，硬件检测到这个特殊 LR 值，就会自动触发 **异常返回（Exception Return）** 流程：

- 从栈中弹出之前保存的 PC、LR、R0–R3 等寄存器  
- 恢复中断前的 CPU 状态  
- 跳转回中断前的代码继续执行

## PenSV中的上下文切换过程

PendSV 中断服务函数主要完成两件事：

- 保存当前线程的上下文
- 恢复下一个要运行线程的上下文

### 1. 保存当前线程上下文

如果当前有线程正在运行，PendSV 会执行以下操作：

- 将 通用寄存器 r4–r11 压入线程栈（r0–r3、r12、lr、pc、xPSR 已由硬件自动入栈）
- 如果启用了 VFP：
    - 保存 浮点寄存器 s16–s31
    - 将当前的 LR（EXC_RETURN） 一并保存
    - 将当前线程的 栈指针（PSP） 保存到线程控制块（TCB）中

至此，当前线程的执行现场被完整保存。

### 2. 恢复新线程上下文

接下来，PendSV 切换到即将运行的新线程：

- 从新线程的 TCB 中取出保存的 栈指针

- 依次从栈中恢复：
    - LR（EXC_RETURN）
    - 若启用 VFP，恢复 s16–s31
    - 恢复 r4–r11
- 将 PSP 设置为新线程的栈指针
- 执行：bx lr

此时 CPU 会自动从异常返回，硬件完成：恢复 r0–r3、r12、pc、xPSR

线程从上次停止的位置继续运行
